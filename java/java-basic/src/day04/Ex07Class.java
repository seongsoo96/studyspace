package day04;

/*
 *  클래스
 *  클래스란 하나의 별개의 프로그램이다.
 *  객체지향프로그래밍에서는 프로그램이 기능을 불러다 쓰는 것이 아니라
 *  프로그램 통재로 가져다가 쓰는것을 목표로 한다.
 *  
 *  즉 커다란 프로그램이 작은 프로그램들을 불러서 쓰는데
 *  그 작은 프로그램을 커다란 프로그램에 등록할 때
 *  변수를 선언하듯이 선언과 초기화해서 사용하게 된다.
 *  
 *  작은 프로그램의 기능을 실행시키면 그 작은 프로그램이 내부적으로
 *  해당 기능을 실행시키고 그 결과값을 큰 프로그램에 보내주게 된다.
 *  
 *  예를 들어서 우리가 키보드 입력을 할때에는 
 *  해당 기능을 담당하는 Scanner 클래스 타입의 변수를 만들어서
 *  걔가 알아서 하도록 우리가 기능만 호출해준다.
 *  
 *  그리고 이러한 클래스 타입의 변수를 우리가 객체라고 부른다.
 *  즉 객체지향프로그래밍(Object Oriented Programming)이란
 *  그러한 작은 프로그램들을 다양하게 만들어서 우리가 필요할 때
 *  그 작은 프로그램 변수들만 가져다 쓰는게 객체지향프로그래밍이 지향하는 바이다.
 *  
 *  클래스의 구성요소
 *  클래스는 필드와 메소드로 이루어져있다.
 *  필드: 해당 클래스 변수가 가지고 있을 정보의 틀
 *       예시-> 학생의 경우 학번, 이름, 국어, 영어, 수학등의 점수들
 *       클래스에서 필드를 만들때에는 우리가 메소드안에서 변수를 만들듯이
 *       "데이터타입 필드이름" 으로 선언해주면 된다.
 *       
 *  메소드: 메소드란 해당 클래스의 변수들이 
 *        가지고 있을 기능을 선언/구현해 놓은 것이다.
 *        
 *        메소드를 선언할 때에는
 *        리턴타입 이름(파라미터) 로 선언한다.
 *        
 *        리턴 타입: 해당 기능이 종료될때 호출된 곳으로 보내줄 데이터의 데이터타입.
 *                 만약 해당 메소드가 아무런 값도 보내주지 않는다면 
 *                 void 라고 적어주어야 한다.
 *                 또한 만약 리턴 타입이 void가 아니라면
 *                 해당 타입과 일치하는 데이터를 반드시
 *                 return 키워드와 합쳐서 메소드 내부에 있어야 한다.
 *                 반대로 리턴타입이 void이면
 *                 return 키워드를 적으면 에러가 난다!
 *                 또한 메소드 내부에서 return 이 나오면
 *                 해당 메소드는 그 라인에서 종료가 된다.
 *                 
 *        이름: 소문자로 시작하는 동사
 *        
 *        파라미터: 파라미터란 해당 메소드를 실행시킬 때 필요로 하는 외부의 
 *                값을 변수의 형태로 지정한 것이다.
 *                외부에서 보내줄 때 뭐라고 보내주던 간에 
 *                해당 메소드 내부에서는 우리가 지정한 이름으로 호출된다.
 *                
 *                또한 파라미터는 필드와 이름이 같을 수도 있는데
 *                이때는 해당 이름을 쓰면 파라미터가 호출된다.
 *                예시 -> 필드에도 id가 있고 파라미터에도 id가 있으면
 *                       메소드 내부에서 id는 파라미터로 넘어온 id를 뜻한다.
 *                       이럴 때에는 필드를 지칭할 때 필드이름 앞에
 *                       this.을 붙여서 해당 이름은 필드라는 것을
 *                       명시해주면 된다.
 *       
 *  static: static이란 자바에서 해당 필드 혹은 메소드를 객체 생성 없이
 *          사용할수 있도록 등록하는 키워드이다.
 *          단, 객체 생성을 하지 않는다는 것은 객체지향프로그래밍의 목표와는
 *          정반대이므로, 더이상 static 키워드를 우리가 만드는 메소드에 사용하는
 *          것은 추천되지 않는다.
 *          
 *          또한 static 키워드가 붙은 메소드 같은 클래스에 있는
 *          필드나 메소드를 호출할려고 하면, 그 다른 필드나 메소드에도 static이
 *          붙어야 한다! 
 *  
 *  생성자(Constructor)
 *  생성자란, 해당 클래스의 객체가 생성될때 호출되는 메소드로써
 *  뭔가 초기화 작업이 필요할 경우, 생성자가 해주게 된다.
 *  우리가 따로 생성자를 만들어주지 않더라도
 *  자바가 기본적으로 제공해주는 생성자가
 *  필드를 초기화해준다.
 *  만약 필드의 데이터타입이 기본형일 경우 0으로 초기화해준다.
 *  만약 필드의 데이터타입이 참조형일 경우 null로 초기화해준다.
 *  
 *  생성자의 경우, 우리가 직접 필드를 어떤 값으로 초기화할지 혹은
 *  어떤 코드를 실행할지 직접 만들어 줄 수도 있는데
 *  우리가 직접 생성자를 만들 경우, 자바가 기본적으로 제공해주는 기본 생성자는
 *  더이상 호출할 수 없다.
 *  
 *  생성자는 리턴타입 없이
 *  클래스와 메소드의 이름이 같고 맨 앞에 public이 붙으면 된다.
 *  
 *  단, 클래스에 파라미터가 있는 생성자만 만들어주게 된다면
 *  더이상 파라미터 없는 생성자 혹은 기본 생성자는 호출이 불가능해진다.
 *  
 *  메소드 오버로딩(overloading)
 *  메소드 오버로딩이란 파라미터를 다르게 해서 같은 목적을 가진 메소드들의
 *  이름을 통일 시켜주는 방법을 메소드 오버로딩이라고 한다.
 *  예시: System.out.println()의 다양한 파라미터들!
 *  
 *  자, 그렇다면 파라미터가 다르다는건 무슨 뜻일까?
 *  
 *  1. (int id, String name, int korean, int english, int math)
 *     (int id, String name)
 *  
 *  2. (int id, String name)
 *     (String name, int id)
 *  
 *  3. (int korean, int english, int math)
 *     (int math, int korean, int english)
 *  
 *  1번의 두개의 파라미터는 서로 다른 파라미터이다. 왜냐하면 갯수가 틀리기 때문.
 *  만약 우리가 (1, "조재영") 이라고 하면 명확하게
 *  어떤 메소드가 호출될지 결정된다.
 *  
 *  2번의 두개의 파라미터는 서로 다른 파라미터이다. 왜냐하면 순서가 틀리기 때문.
 *  만약 우리가 ("조재영", 1) 이라고 하면 명확하게
 *  어떤 메소드가 호출될지 결정된다.
 *  
 *  3번의 두개의 파라미터는 서로 같은 파라미터이다. 왜냐하면 
 *  우리가 (80, 80, 81)이라고 하면 어떤 메소드가 호출될지 애매모호하기 때문이다.
 *  
 *  메소드의 파라미터가 같은지 다른지를 볼때에는
 *  파라미터의 이름은 무시하고 
 *  파라미터의 타입의 순서가 같은지를 비교하면 된다.
 *  
 *  상속
 *  프로그래밍에서 상속은 부모클래스의 메소드를 자식클래스가 다시 선언/구현을
 *  하지 않아도 그대로 사용할 수 있게 코드의 재사용성을 높여주는 방법이다.
 *  우리가 비록 Student 클래스 혹은 다른 클래스에 상속 명령어를 적지 않아도
 *  자바가 몰래 java.lang.Object를 상속한다.
 *  
 *  그래서 우리가 몇몇 메소드(toString(), equals()등)들은 따로 구현을
 *  하지 않아도 실행시킬 수 있다. 
 *  
 *  하지만 java.lang.Object 는 우리 클래스에 어떤 필드가 있는지 혹은
 *  어떤 값을 중심으로 같은지 다른지 비교를 할지를 모르기 때문에
 *  java.lang.Object의 메소드들은 전부 매우 애매모호하게 구현되어있다.
 *  
 *  따라서 우리 클래스의 객체가 해당 메소드들을 제대로 사용할려면
 *  우리가 직접 재정의해주어야 한다.
 *  이렇게 부모 클래스로부터 상속받은 메소드들을 자식 클래스가 재정의하는 것을
 *  오버라이딩(overriding)이라고 한다.
 *  오버라이딩을 할때 주의해야할 점은 부모클래스가 메소드를 선언한 방법 그대로
 *  선언해주어야 한단 것이다.
 *  
 *  // 1. toString()
 *  //    toString() 메소드는 해당 객체의 정보를 String으로 바꿔준다.
 *  //    System.out.println()의 경우, 파라미터로 Object 클래스 혹은
 *  //    Object 클래스를 상속받는 모든 클래스의 객체가 파라미터로 들어오면
 *  //    해당 객체의 toString() 결과값을 화면에 출력해준다.
 *  //    java.lang.Object클래스는 toString()에 해당 클래스의 정보
 *  //    (패키지+클래스이름)와 해당 객체의 메모리 주소값을 String으로 바꿔서
 *  //    return 해준다.
 *  //    만약 우리가 만든 클래스의 객체를 System.out.println()에 넣어서
 *  //    현재 해당 객체의 필드값을 출력하게 만들려면
 *  //    우리가 직접 toString()을 재정의해야한다.
 *  //    toString()은 다음과 같이 선언되어있다.
 *  //    public String toString()
 * 
 *  // 2. equals()
 *  //    비교연산자 == 의 경우, 객체끼리 비교하면
 *  //    주소값 비교를 하기 때문에, 객체의 필드값 비교를 위해서는
 *  //    equals()를 통해서 비교해야한다.
 *  //    이 equals() 메소드도 java.lang.Object에 정의되어있다.
 *  //    근데 toString()과 마찬가지로 java.lang.Object는
 *  //    해당 클래스의 어떤 필드를 기준으로 비교를 할지 알까?
 *  //    당연히 모른다.
 *  //    그래서 충격적이게도 java.lang.Object의 equals()는
 *  //    다음과 같이 생겼다.
 *  
 *  //    public boolean equals(Object o){
 *  //        return this == o;
 *  //    }
 *  
 *  //    즉 주소값 비교를 하게되는 것이다.
 *  //    따라서 우리 클래스 객체의 필드를 기준으로 해서 비교를 할려면
 *  //    toString()과 마찬가지로, 우리가 오버라이드 해야한다!!!
 *  
 *  null
 *  null이란 참조형 변수/상수에서만 발견되는 특수한 상황이다.
 *  정상적으로 초기화된 참조형 변수/상수는
 *  변수/상수 자체는 주소값을 가지고 있고
 *  그 주소값을 찾아서 들어가면 실제 해당 데이터타입의 값들이 존재하는 형태가 된다.
 *  
 *  그런데 만약, 그 주소값을 찾아서 들어간 곳에, 아무런 정보가 없다면?
 *  그 참조형 변수/상수의 필드 혹은 메소드 등 상세한 정보를 전혀 알 수 없게 된다.
 *  이렇게 해당 메모리 주소에 아무것도 없는 상태를 null이라고,
 *  null인 참조형 변수/상수의 필드 혹은 메소드를 호출하면
 *  NullPointerException 이라는 에러가 발생하게 된다!!!
 *  
 *  
 *   다형성(polymorphism)
 *   다형성이란 다양한 모습을 가지는 성격이라고 할 수 있다.
 *   자바에서는 부모클래스가 파라미터로 적히는 경우
 *   자식 클래스도 파라미터로 들어올 수 있다.
 *   
 *   
 *   접근제한자(Access Modifier)
 *   접근제한자란 해당 필드 혹은 메소드의 접근 범위를 결정하는 키워드이다.
 *   public > protected > default > private 순의 범위이다.
 *   public: 내부 패키지의 외부 클래스나 외부 패키지으 ㅣ외부 클래스나
 *   		 어디서든 접근 가능(객체를 만들어서 해당 필드 혹은 메소드를 호출가능)
 *   
 *   protected: 내부 패키지의 다른 클래스면 접근 가능하지만
 *   			외부 패키지에선 해당 클래스를 상속받는 클래스만 접근 가능
 *   
 *   default: 내부 패키지의 다른 클래스면 접근 가능하지만
 *   		  외부 패키지의 모든 클래스는 접근 안됨
 *   		  이렇기 때문에 패키지 접근제한자라고도 불리지만
 *   		  default와 package 모두 다른곳에서 쓰이는 키워드이기 때문에
 *   		  우리가 아무런 접근 제한자를 메소드나 필드에 붙이지 않으면
 *   		  자동으로 default 접근제한자가 적용된다.
 *   
 *   private: 외부 클래스면 모두 접근이 불가능.
 *   
 *   예전에는 정말정말 외부에 알려주기 싫은 메소드 혹은 필드만 private으로 해두고
 *   나머지는 전부 public으로 두어도 괜찮았다.
 *   하지만 이제는 캡슐화라는 개념때문에 외부가 꼭 알아야할 메소드를 제외하고서는
 *   모든 필드 -> private
 *   거의 모든 메소드 -> public
 *   으로 접근제한을 하게 된다.
 *   
 *   캡슐화란 객체를 만들면 굳이 그 객체의 내용을 다른 외부가 알 필요없고
 *   그 객체 자체를 쓰면 된다는 관점에서 접근하는 것이다.
 *   
 *   하지만 필드의 경우 private 접근제한자가 적용되면
 *   외부에서 값을 직접 넘겨주거나 호출하는 것이 불가능해진다.
 *   
 *   
 *   그래서 이제는 메소드를 통해서 간접적으로 필드에 값을 저장하고
 *   저장된 값을 리턴하는 방법을 쓰게 된다.
 *   
 *   외부로부터 값을 받아서 필드에 값을 할당하는 메소드는 setter 메소드라고 한다.
 *   setter 메소드는 다음과 같은 "양식"을 가진다.
 *   public void set필드이름(필드타입 필드이름){
 *   	this.필드이름 = 필드이름; 
 *   }
 *   만약 값을 저장할 때, 추가적으로 작업할 것이 있다면, setter메소드 내부에
 *   구현하면 된다.
 *  
 *  
 *   필드에 저장된 값을 호출된 곳으로 리턴하는 메소드는 getter 메소드라고 한다.
 *   getter 메소드는 다음과 같은 "양식"을 가진다.
 *   public 필드타입 get필드이름(){
 *   	return 필드이름;
 *   }
 *   만약 값을 리턴할 때, 추가적으로 작업할 것이 있다면 getter메소드 내부에
 *   구현하면 된다.
 *   
 *   
 */
public class Ex07Class {

}









